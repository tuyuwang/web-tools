#!/usr/bin/env node

/**
 * Â¢ûÂº∫ÁâàÊÄßËÉΩÊµãËØïËÑöÊú¨
 * Áî®‰∫éÈ™åËØÅÊûÑÂª∫ËæìÂá∫ÁöÑË¥®ÈáèÂíåÊÄßËÉΩÊåáÊ†á
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

console.log('üîç ÂºÄÂßãÂ¢ûÂº∫ÁâàÊÄßËÉΩÊµãËØï...\n');

// ÊÄßËÉΩÊåáÊ†áÊî∂ÈõÜÂô®
class PerformanceCollector {
  constructor() {
    this.metrics = {
      buildSize: 0,
      bundleAnalysis: {},
      pageMetrics: {},
      resourceOptimization: {},
      cacheability: {},
      accessibility: {},
      seo: {},
      timestamp: new Date().toISOString()
    };
  }

  // Êî∂ÈõÜÊûÑÂª∫Â§ßÂ∞èÊåáÊ†á
  collectBuildMetrics() {
    console.log('üìä Êî∂ÈõÜÊûÑÂª∫ÊåáÊ†á...');
    
    const outDir = path.join(process.cwd(), 'out');
    if (!fs.existsSync(outDir)) {
      console.error('‚ùå ÊûÑÂª∫ËæìÂá∫ÁõÆÂΩï‰∏çÂ≠òÂú®ÔºÅ');
      return false;
    }

    // ËÆ°ÁÆóÊÄªÊûÑÂª∫Â§ßÂ∞è
    const totalSize = this.calculateDirectorySize(outDir);
    this.metrics.buildSize = totalSize;

    // ÂàÜÊûêÂêÑÁ±ªÊñá‰ª∂Â§ßÂ∞è
    const fileTypes = this.analyzeFileTypes(outDir);
    this.metrics.bundleAnalysis = fileTypes;

    console.log(`‚úÖ ÊÄªÊûÑÂª∫Â§ßÂ∞è: ${(totalSize / 1024 / 1024).toFixed(2)}MB`);
    
    return true;
  }

  // ËÆ°ÁÆóÁõÆÂΩïÂ§ßÂ∞è
  calculateDirectorySize(dirPath) {
    let totalSize = 0;
    const items = fs.readdirSync(dirPath);

    items.forEach(item => {
      const itemPath = path.join(dirPath, item);
      const stats = fs.statSync(itemPath);

      if (stats.isDirectory()) {
        totalSize += this.calculateDirectorySize(itemPath);
      } else {
        totalSize += stats.size;
      }
    });

    return totalSize;
  }

  // ÂàÜÊûêÊñá‰ª∂Á±ªÂûãÂàÜÂ∏É
  analyzeFileTypes(dirPath) {
    const fileTypes = {
      javascript: { count: 0, size: 0 },
      css: { count: 0, size: 0 },
      html: { count: 0, size: 0 },
      images: { count: 0, size: 0 },
      fonts: { count: 0, size: 0 },
      other: { count: 0, size: 0 }
    };

    const analyzeDir = (dir) => {
      const items = fs.readdirSync(dir);
      
      items.forEach(item => {
        const itemPath = path.join(dir, item);
        const stats = fs.statSync(itemPath);

        if (stats.isDirectory()) {
          analyzeDir(itemPath);
        } else {
          const ext = path.extname(item).toLowerCase();
          const size = stats.size;

          switch (ext) {
            case '.js':
            case '.mjs':
              fileTypes.javascript.count++;
              fileTypes.javascript.size += size;
              break;
            case '.css':
              fileTypes.css.count++;
              fileTypes.css.size += size;
              break;
            case '.html':
              fileTypes.html.count++;
              fileTypes.html.size += size;
              break;
            case '.png':
            case '.jpg':
            case '.jpeg':
            case '.gif':
            case '.svg':
            case '.webp':
              fileTypes.images.count++;
              fileTypes.images.size += size;
              break;
            case '.woff':
            case '.woff2':
            case '.ttf':
            case '.eot':
              fileTypes.fonts.count++;
              fileTypes.fonts.size += size;
              break;
            default:
              fileTypes.other.count++;
              fileTypes.other.size += size;
          }
        }
      });
    };

    analyzeDir(dirPath);
    return fileTypes;
  }

  // Ê£ÄÊü•È°µÈù¢ÊÄßËÉΩÊåáÊ†á
  collectPageMetrics() {
    console.log('\nüöÄ ÂàÜÊûêÈ°µÈù¢ÊÄßËÉΩÊåáÊ†á...');
    
    const outDir = path.join(process.cwd(), 'out');
    const htmlFiles = this.findHtmlFiles(outDir);
    
    htmlFiles.forEach(htmlFile => {
      const relativePath = path.relative(outDir, htmlFile);
      const content = fs.readFileSync(htmlFile, 'utf8');
      
      this.metrics.pageMetrics[relativePath] = {
        size: fs.statSync(htmlFile).size,
        scriptTags: (content.match(/<script/g) || []).length,
        styleTags: (content.match(/<style/g) || []).length,
        linkTags: (content.match(/<link/g) || []).length,
        imageTags: (content.match(/<img/g) || []).length,
        hasServiceWorker: content.includes('sw.js'),
        hasManifest: content.includes('manifest.json'),
        title: this.extractTitle(content),
        metaTags: (content.match(/<meta/g) || []).length
      };
    });

    console.log(`‚úÖ ÂàÜÊûê‰∫Ü ${htmlFiles.length} ‰∏™HTMLÊñá‰ª∂`);
  }

  // Êü•ÊâæHTMLÊñá‰ª∂
  findHtmlFiles(dir) {
    const htmlFiles = [];
    
    const searchDir = (searchPath) => {
      const items = fs.readdirSync(searchPath);
      
      items.forEach(item => {
        const itemPath = path.join(searchPath, item);
        const stats = fs.statSync(itemPath);
        
        if (stats.isDirectory()) {
          searchDir(itemPath);
        } else if (path.extname(item).toLowerCase() === '.html') {
          htmlFiles.push(itemPath);
        }
      });
    };
    
    searchDir(dir);
    return htmlFiles;
  }

  // ÊèêÂèñÈ°µÈù¢Ê†áÈ¢ò
  extractTitle(content) {
    const titleMatch = content.match(/<title>(.*?)<\/title>/i);
    return titleMatch ? titleMatch[1] : 'No title';
  }

  // Ê£ÄÊü•ËµÑÊ∫ê‰ºòÂåñ
  checkResourceOptimization() {
    console.log('\n‚ö° Ê£ÄÊü•ËµÑÊ∫ê‰ºòÂåñ...');
    
    const outDir = path.join(process.cwd(), 'out');
    
    // Ê£ÄÊü•ÂéãÁº©Êñá‰ª∂
    const hasGzipFiles = this.checkForFiles(outDir, '.gz');
    const hasBrotliFiles = this.checkForFiles(outDir, '.br');
    
    // Ê£ÄÊü•ÂõæÁâá‰ºòÂåñ
    const imageOptimization = this.checkImageOptimization(outDir);
    
    // Ê£ÄÊü•CSSÂíåJSÂéãÁº©
    const assetOptimization = this.checkAssetOptimization(outDir);
    
    this.metrics.resourceOptimization = {
      gzipCompression: hasGzipFiles,
      brotliCompression: hasBrotliFiles,
      imageOptimization,
      assetOptimization
    };

    console.log(`‚úÖ ËµÑÊ∫ê‰ºòÂåñÊ£ÄÊü•ÂÆåÊàê`);
  }

  // Ê£ÄÊü•ÁâπÂÆöÊâ©Â±ïÂêçÁöÑÊñá‰ª∂
  checkForFiles(dir, extension) {
    const checkDir = (searchPath) => {
      const items = fs.readdirSync(searchPath);
      
      for (const item of items) {
        const itemPath = path.join(searchPath, item);
        const stats = fs.statSync(itemPath);
        
        if (stats.isDirectory()) {
          if (checkDir(itemPath)) return true;
        } else if (item.endsWith(extension)) {
          return true;
        }
      }
      return false;
    };
    
    return checkDir(dir);
  }

  // Ê£ÄÊü•ÂõæÁâá‰ºòÂåñ
  checkImageOptimization(dir) {
    const imageStats = {
      total: 0,
      webpCount: 0,
      avgSize: 0,
      largeImages: []
    };

    const checkImages = (searchPath) => {
      const items = fs.readdirSync(searchPath);
      
      items.forEach(item => {
        const itemPath = path.join(searchPath, item);
        const stats = fs.statSync(itemPath);
        
        if (stats.isDirectory()) {
          checkImages(itemPath);
        } else {
          const ext = path.extname(item).toLowerCase();
          if (['.png', '.jpg', '.jpeg', '.gif', '.svg', '.webp'].includes(ext)) {
            imageStats.total++;
            imageStats.avgSize += stats.size;
            
            if (ext === '.webp') {
              imageStats.webpCount++;
            }
            
            if (stats.size > 100 * 1024) { // Â§ß‰∫é100KB
              imageStats.largeImages.push({
                path: path.relative(dir, itemPath),
                size: stats.size
              });
            }
          }
        }
      });
    };

    checkImages(dir);
    
    if (imageStats.total > 0) {
      imageStats.avgSize = imageStats.avgSize / imageStats.total;
    }

    return imageStats;
  }

  // Ê£ÄÊü•ËµÑÊ∫êÂéãÁº©
  checkAssetOptimization(dir) {
    const optimization = {
      minifiedJS: 0,
      minifiedCSS: 0,
      totalJS: 0,
      totalCSS: 0
    };

    const checkAssets = (searchPath) => {
      const items = fs.readdirSync(searchPath);
      
      items.forEach(item => {
        const itemPath = path.join(searchPath, item);
        const stats = fs.statSync(itemPath);
        
        if (stats.isDirectory()) {
          checkAssets(itemPath);
        } else {
          const ext = path.extname(item).toLowerCase();
          
          if (ext === '.js') {
            optimization.totalJS++;
            if (item.includes('.min.') || this.isMinified(itemPath)) {
              optimization.minifiedJS++;
            }
          } else if (ext === '.css') {
            optimization.totalCSS++;
            if (item.includes('.min.') || this.isMinified(itemPath)) {
              optimization.minifiedCSS++;
            }
          }
        }
      });
    };

    checkAssets(dir);
    return optimization;
  }

  // ÁÆÄÂçïÊ£ÄÊü•Êñá‰ª∂ÊòØÂê¶Ë¢´ÂéãÁº©
  isMinified(filePath) {
    try {
      const content = fs.readFileSync(filePath, 'utf8');
      const lines = content.split('\n');
      
      // Â¶ÇÊûúÂπ≥ÂùáË°åÈïøÂ∫¶ÂæàÈïø‰∏îÊç¢Ë°åÂæàÂ∞ëÔºåÂèØËÉΩÊòØÂéãÁº©ÁöÑ
      const avgLineLength = content.length / lines.length;
      return avgLineLength > 200 && lines.length < 10;
    } catch {
      return false;
    }
  }

  // Ê£ÄÊü•ÁºìÂ≠òÁ≠ñÁï•
  checkCacheability() {
    console.log('\nüíæ Ê£ÄÊü•ÁºìÂ≠òÁ≠ñÁï•...');
    
    const outDir = path.join(process.cwd(), 'out');
    const cacheAnalysis = {
      hashedFiles: 0,
      totalStaticFiles: 0,
      serviceWorker: false,
      manifest: false
    };

    const checkCache = (searchPath) => {
      const items = fs.readdirSync(searchPath);
      
      items.forEach(item => {
        const itemPath = path.join(searchPath, item);
        const stats = fs.statSync(itemPath);
        
        if (stats.isDirectory()) {
          checkCache(itemPath);
        } else {
          const ext = path.extname(item).toLowerCase();
          
          if (['.js', '.css', '.png', '.jpg', '.jpeg', '.gif', '.svg', '.webp'].includes(ext)) {
            cacheAnalysis.totalStaticFiles++;
            
            // Ê£ÄÊü•ÊòØÂê¶ÊúâhashÔºàÈÄöÂ∏∏ÂåÖÂê´8+Â≠óÁ¨¶ÁöÑÈöèÊú∫Â≠óÁ¨¶‰∏≤Ôºâ
            if (/[a-f0-9]{8,}/.test(item)) {
              cacheAnalysis.hashedFiles++;
            }
          }
          
          if (item === 'sw.js') {
            cacheAnalysis.serviceWorker = true;
          }
          
          if (item === 'manifest.json') {
            cacheAnalysis.manifest = true;
          }
        }
      });
    };

    checkCache(outDir);
    this.metrics.cacheability = cacheAnalysis;

    console.log(`‚úÖ ÁºìÂ≠òÁ≠ñÁï•Ê£ÄÊü•ÂÆåÊàê`);
  }

  // ÁîüÊàêÊÄßËÉΩÊä•Âëä
  generateReport() {
    console.log('\nüìÑ ÁîüÊàêÊÄßËÉΩÊä•Âëä...');
    
    const report = {
      ...this.metrics,
      summary: this.generateSummary(),
      recommendations: this.generateRecommendations(),
      score: this.calculatePerformanceScore()
    };

    const reportPath = 'performance-report.json';
    fs.writeFileSync(reportPath, JSON.stringify(report, null, 2));
    
    console.log(`‚úÖ ËØ¶ÁªÜÊä•ÂëäÂ∑≤‰øùÂ≠òÂà∞: ${reportPath}`);
    return report;
  }

  // ÁîüÊàêÊëòË¶Å
  generateSummary() {
    const buildSizeMB = (this.metrics.buildSize / 1024 / 1024).toFixed(2);
    const pageCount = Object.keys(this.metrics.pageMetrics).length;
    
    return {
      buildSizeMB: parseFloat(buildSizeMB),
      pageCount,
      hasServiceWorker: this.metrics.cacheability.serviceWorker,
      hasManifest: this.metrics.cacheability.manifest,
      imageOptimizationRatio: this.metrics.resourceOptimization.imageOptimization.webpCount / 
        Math.max(this.metrics.resourceOptimization.imageOptimization.total, 1)
    };
  }

  // ÁîüÊàêÂª∫ËÆÆ
  generateRecommendations() {
    const recommendations = [];
    
    // ÊûÑÂª∫Â§ßÂ∞èÂª∫ËÆÆ
    if (this.metrics.buildSize > 25 * 1024 * 1024) {
      recommendations.push({
        type: 'build-size',
        priority: 'high',
        message: 'ÊûÑÂª∫ÂåÖÂ§ßÂ∞èË∂ÖËøá25MBÈôêÂà∂',
        action: 'ËÄÉËôë‰ª£Á†ÅÂàÜÂâ≤„ÄÅÁßªÈô§Êú™‰ΩøÁî®‰æùËµñ„ÄÅÂéãÁº©ËµÑÊ∫ê'
      });
    }

    // ÂõæÁâá‰ºòÂåñÂª∫ËÆÆ
    const imageOpt = this.metrics.resourceOptimization.imageOptimization;
    if (imageOpt.total > 0 && imageOpt.webpCount / imageOpt.total < 0.5) {
      recommendations.push({
        type: 'image-optimization',
        priority: 'medium',
        message: 'Âª∫ËÆÆ‰ΩøÁî®Êõ¥Â§öWebPÊ†ºÂºèÂõæÁâá',
        action: 'ËΩ¨Êç¢PNG/JPEGÂõæÁâá‰∏∫WebPÊ†ºÂºè‰ª•ÂáèÂ∞ëÂ§ßÂ∞è'
      });
    }

    // ÁºìÂ≠òÁ≠ñÁï•Âª∫ËÆÆ
    const cache = this.metrics.cacheability;
    if (cache.hashedFiles / Math.max(cache.totalStaticFiles, 1) < 0.8) {
      recommendations.push({
        type: 'caching',
        priority: 'medium',
        message: 'ÈùôÊÄÅËµÑÊ∫êÁº∫Â∞ëÊñá‰ª∂ÂêçÂìàÂ∏å',
        action: '‰∏∫ÈùôÊÄÅËµÑÊ∫êÊ∑ªÂä†ÂÜÖÂÆπÂìàÂ∏å‰ª•ÊîπÂñÑÁºìÂ≠òÁ≠ñÁï•'
      });
    }

    // PWAÂª∫ËÆÆ
    if (!cache.serviceWorker || !cache.manifest) {
      recommendations.push({
        type: 'pwa',
        priority: 'low',
        message: 'PWAÂäüËÉΩ‰∏çÂÆåÊï¥',
        action: 'Ê∑ªÂä†Service WorkerÂíåWeb App Manifest'
      });
    }

    return recommendations;
  }

  // ËÆ°ÁÆóÊÄßËÉΩÂàÜÊï∞
  calculatePerformanceScore() {
    let score = 100;
    
    // ÊûÑÂª∫Â§ßÂ∞èËØÑÂàÜ (30ÂàÜ)
    const buildSizeMB = this.metrics.buildSize / 1024 / 1024;
    if (buildSizeMB > 25) score -= 30;
    else if (buildSizeMB > 15) score -= 20;
    else if (buildSizeMB > 10) score -= 10;
    else if (buildSizeMB > 5) score -= 5;

    // ËµÑÊ∫ê‰ºòÂåñËØÑÂàÜ (25ÂàÜ)
    const imageOpt = this.metrics.resourceOptimization.imageOptimization;
    const webpRatio = imageOpt.total > 0 ? imageOpt.webpCount / imageOpt.total : 1;
    score -= (1 - webpRatio) * 15;

    const assetOpt = this.metrics.resourceOptimization.assetOptimization;
    const jsMinRatio = assetOpt.totalJS > 0 ? assetOpt.minifiedJS / assetOpt.totalJS : 1;
    const cssMinRatio = assetOpt.totalCSS > 0 ? assetOpt.minifiedCSS / assetOpt.totalCSS : 1;
    score -= (2 - jsMinRatio - cssMinRatio) * 5;

    // ÁºìÂ≠òÁ≠ñÁï•ËØÑÂàÜ (25ÂàÜ)
    const cache = this.metrics.cacheability;
    const hashRatio = cache.totalStaticFiles > 0 ? cache.hashedFiles / cache.totalStaticFiles : 1;
    score -= (1 - hashRatio) * 15;
    
    if (!cache.serviceWorker) score -= 5;
    if (!cache.manifest) score -= 5;

    // È°µÈù¢Ë¥®ÈáèËØÑÂàÜ (20ÂàÜ)
    const pages = Object.values(this.metrics.pageMetrics);
    if (pages.length > 0) {
      const avgScriptTags = pages.reduce((sum, page) => sum + page.scriptTags, 0) / pages.length;
      if (avgScriptTags > 10) score -= 10;
      else if (avgScriptTags > 5) score -= 5;
    }

    return Math.max(0, Math.round(score));
  }
}

// ‰∏ªÂáΩÊï∞
async function main() {
  try {
    const collector = new PerformanceCollector();
    
    // Êî∂ÈõÜÂêÑÈ°πÊåáÊ†á
    if (!collector.collectBuildMetrics()) {
      process.exit(1);
    }
    
    collector.collectPageMetrics();
    collector.checkResourceOptimization();
    collector.checkCacheability();
    
    // ÁîüÊàêÊä•Âëä
    const report = collector.generateReport();
    
    // ËæìÂá∫ÊÄªÁªì
    console.log('\nüéØ ÊÄßËÉΩÊµãËØïÊÄªÁªì:');
    console.log(`üì¶ ÊûÑÂª∫Â§ßÂ∞è: ${report.summary.buildSizeMB}MB`);
    console.log(`üìÑ È°µÈù¢Êï∞Èáè: ${report.summary.pageCount}`);
    console.log(`‚ö° ÊÄßËÉΩËØÑÂàÜ: ${report.score}/100`);
    console.log(`üí° ‰ºòÂåñÂª∫ËÆÆ: ${report.recommendations.length}Êù°`);
    
    // ËæìÂá∫Âª∫ËÆÆ
    if (report.recommendations.length > 0) {
      console.log('\nüìã ‰ºòÂåñÂª∫ËÆÆ:');
      report.recommendations.forEach((rec, index) => {
        const priority = rec.priority === 'high' ? 'üî¥' : rec.priority === 'medium' ? 'üü°' : 'üü¢';
        console.log(`${index + 1}. ${priority} ${rec.message}`);
        console.log(`   ‚û°Ô∏è  ${rec.action}`);
      });
    }
    
    // Ê†πÊçÆËØÑÂàÜÁªôÂá∫ÊÄª‰ΩìËØÑ‰ª∑
    if (report.score >= 90) {
      console.log('\nüéâ ‰ºòÁßÄÔºÅÊÄßËÉΩË°®Áé∞Âá∫Ëâ≤');
    } else if (report.score >= 75) {
      console.log('\n‚úÖ ËâØÂ•ΩÔºÅÊÄßËÉΩË°®Áé∞‰∏çÈîô');
    } else if (report.score >= 60) {
      console.log('\n‚ö†Ô∏è  ‰∏ÄËà¨ÔºÅÂª∫ËÆÆËøõË°å‰ºòÂåñ');
    } else {
      console.log('\nüö® ÈúÄË¶ÅÊîπËøõÔºÅËØ∑Á´ãÂç≥‰ºòÂåñ');
    }
    
  } catch (error) {
    console.error('‚ùå ÊÄßËÉΩÊµãËØïËøáÁ®ã‰∏≠ÂèëÁîüÈîôËØØ:', error.message);
    process.exit(1);
  }
}

main(); 